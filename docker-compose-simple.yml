     services:
       mysql-rbac:
         image: mysql:8.0
         container_name: artyco-mysql-rbac
         environment:
           MYSQL_ROOT_PASSWORD: rootpassword123
           MYSQL_DATABASE: artyco_financial_rbac
           MYSQL_USER: artyco_user
           MYSQL_PASSWORD: artyco_password123
         ports:
           - "3307:3306"
         volumes:
           - mysql-rbac-data:/var/lib/mysql
         command: --default-authentication-plugin=mysql_native_password

       api-rbac:
         image: python:3.12-slim
         container_name: artyco-api-rbac
         working_dir: /app
         environment:
           - DATABASE_URL=mysql+pymysql://artyco_user:artyco_password123@mysql-rbac:3306/artyco_financial_rbac
           - JWT_SECRET_KEY=your-super-secret-jwt-key-change-this-in-production
           - CORS_ORIGINS=http://localhost:3001,http://localhost:8001
           - PYTHONUNBUFFERED=1
         ports:
           - "8001:8000"
         volumes:
           - .:/app
         depends_on:
           - mysql-rbac
         restart: unless-stopped
         command: >
           bash -c "
             echo 'üîß Installing dependencies...' &&
             apt-get update &&
             apt-get install -y gcc default-libmysqlclient-dev pkg-config curl &&
             pip install --no-cache-dir fastapi uvicorn PyJWT passlib[bcrypt] python-multipart sqlalchemy pymysql alembic
     python-dotenv &&
             echo '‚è≥ Waiting for database...' &&
             sleep 15 &&
             echo 'üóÑÔ∏è Setting up database...' &&
             python -c \"
     import time, os
     from sqlalchemy import create_engine, text
     engine = create_engine(os.getenv('DATABASE_URL'))
     for i in range(30):
         try:
             with engine.connect() as conn:
                 conn.execute(text('SELECT 1'))
             print('‚úÖ Database connected!')
             break
         except Exception as e:
             print(f'‚è≥ Waiting for database... {i+1}/30')
             time.sleep(2)
     else:
         print('‚ùå Database connection failed')
         exit(1)

     # Create basic tables
     with engine.connect() as conn:
         conn.execute(text('''
             CREATE TABLE IF NOT EXISTS users (
                 id INT AUTO_INCREMENT PRIMARY KEY,
                 username VARCHAR(100) UNIQUE NOT NULL,
                 email VARCHAR(255) UNIQUE NOT NULL,
                 password_hash VARCHAR(255) NOT NULL,
                 first_name VARCHAR(100),
                 last_name VARCHAR(100),
                 is_active BOOLEAN DEFAULT TRUE,
                 is_superuser BOOLEAN DEFAULT FALSE,
                 created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                 updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                 last_login TIMESTAMP NULL
             ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
         '''))

         conn.execute(text('''
             INSERT INTO users (username, email, password_hash, first_name, last_name, is_superuser)
             VALUES ('admin', 'admin@artyco.com', '\$2b\$12\$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewKyNiGSqGqUDS6C', 'System',
     'Administrator', TRUE)
             ON DUPLICATE KEY UPDATE updated_at = CURRENT_TIMESTAMP
         '''))

         conn.commit()
         print('‚úÖ Database tables created!')
             \" &&
             echo 'üöÄ Starting API server...' &&
             python -c \"
     from fastapi import FastAPI, HTTPException, Depends
     from fastapi.middleware.cors import CORSMiddleware
     from fastapi.security import HTTPBearer
     from pydantic import BaseModel
     import uvicorn
     import jwt
     from passlib.context import CryptContext
     from sqlalchemy import create_engine, text
     import os
     from datetime import datetime, timedelta
     from typing import Optional

     app = FastAPI(
         title='Artyco Financial API - RBAC Edition',
         description='API REST con sistema de autenticaci√≥n RBAC',
         version='2.0.0',
         docs_url='/docs',
         redoc_url='/redoc'
     )

     app.add_middleware(
         CORSMiddleware,
         allow_origins=['*'],
         allow_credentials=True,
         allow_methods=['*'],
         allow_headers=['*'],
     )

     pwd_context = CryptContext(schemes=['bcrypt'], deprecated='auto')
     engine = create_engine(os.getenv('DATABASE_URL'))
     security = HTTPBearer()

     class LoginRequest(BaseModel):
         username: str
         password: str

     class TokenResponse(BaseModel):
         access_token: str
         token_type: str
         expires_in: int
         user: dict

     def verify_token(token: str):
         try:
             payload = jwt.decode(token, 'your-super-secret-jwt-key-change-this-in-production', algorithms=['HS256'])
             return payload
         except:
             return None

     def get_current_user(token: str = Depends(security)):
         payload = verify_token(token.credentials)
         if not payload:
             raise HTTPException(status_code=401, detail='Invalid token')
         return payload

     @app.get('/api/health')
     def health():
         return {
             'status': 'healthy',
             'version': '2.0.0',
             'rbac_enabled': True,
             'environment': 'docker',
             'database_connected': True
         }

     @app.post('/api/auth/login', response_model=TokenResponse)
     def login(request: LoginRequest):
         try:
             with engine.connect() as conn:
                 result = conn.execute(
                     text('SELECT id, username, email, password_hash, is_superuser, first_name, last_name FROM users WHERE username =
     :username OR email = :email'),
                     {'username': request.username, 'email': request.username}
                 ).fetchone()

                 if not result or not pwd_context.verify(request.password, result[3]):
                     raise HTTPException(status_code=401, detail='Invalid username or password')

                 # Update last login
                 conn.execute(
                     text('UPDATE users SET last_login = NOW() WHERE id = :id'),
                     {'id': result[0]}
                 )
                 conn.commit()

                 token = jwt.encode({
                     'user_id': result[0],
                     'username': result[1],
                     'email': result[2],
                     'is_superuser': result[4],
                     'exp': datetime.utcnow() + timedelta(hours=24)
                 }, 'your-super-secret-jwt-key-change-this-in-production', algorithm='HS256')

                 return TokenResponse(
                     access_token=token,
                     token_type='bearer',
                     expires_in=86400,
                     user={
                         'id': result[0],
                         'username': result[1],
                         'email': result[2],
                         'first_name': result[5],
                         'last_name': result[6],
                         'is_superuser': result[4],
                         'roles': ['admin'] if result[4] else ['user'],
                         'permissions': ['*:*'] if result[4] else ['financial_data:read']
                     }
                 )
         except HTTPException:
             raise
         except Exception as e:
             print(f'Login error: {e}')
             raise HTTPException(status_code=500, detail='Internal server error')

     @app.get('/api/auth/me')
     def get_me(current_user = Depends(get_current_user)):
         try:
             with engine.connect() as conn:
                 result = conn.execute(
                     text('SELECT id, username, email, first_name, last_name, is_superuser, created_at, last_login FROM users WHERE id
      = :id'),
                     {'id': current_user['user_id']}
                 ).fetchone()

                 if not result:
                     raise HTTPException(status_code=404, detail='User not found')

                 return {
                     'id': result[0],
                     'username': result[1],
                     'email': result[2],
                     'first_name': result[3],
                     'last_name': result[4],
                     'is_superuser': result[5],
                     'created_at': result[6],
                     'last_login': result[7],
                     'roles': ['admin'] if result[5] else ['user'],
                     'permissions': ['*:*'] if result[5] else ['financial_data:read']
                 }
         except HTTPException:
             raise
         except Exception as e:
             print(f'Get user error: {e}')
             raise HTTPException(status_code=500, detail='Internal server error')

     @app.post('/api/auth/logout')
     def logout(current_user = Depends(get_current_user)):
         return {'message': 'Successfully logged out'}

     @app.get('/api/system/info')
     def system_info(current_user = Depends(get_current_user)):
         return {
             'name': 'Artyco Financial API',
             'version': '2.0.0',
             'features': ['RBAC', 'Authentication', 'Financial Analysis'],
             'user': current_user,
             'database': 'Connected'
         }

     @app.get('/')
     def root():
         return {
             'message': 'Artyco Financial API with RBAC',
             'version': '2.0.0',
             'docs': '/docs',
             'health': '/api/health'
         }

     print('üöÄ Starting Artyco Financial API Server with RBAC...')
     print('üì° API available at: http://localhost:8001')
     print('üìö Documentation at: http://localhost:8001/docs')
     print('üîë Default credentials: admin / admin123')

     uvicorn.run(app, host='0.0.0.0', port=8000, log_level='info')
             \""

     volumes:
       mysql-rbac-data: